plugins {
    id 'base'
    id 'de.undercouch.download' version '5.4.0'
}

// Load properties from build.properties
def buildProps = new Properties()
file('build.properties').withInputStream { buildProps.load(it) }

// Project configuration
group = 'com.bearsampp'
version = buildProps.getProperty('release.default.version')

// Define properties
ext {
    // Application configuration
    appconfLang = buildProps.getProperty('appconf.lang')
    appconfTimezone = buildProps.getProperty('appconf.timezone')
    appconfNotepad = buildProps.getProperty('appconf.notepad')
    appconfMaxLogsArchives = buildProps.getProperty('appconf.maxLogsArchives')
    appconfLogsVerbose = buildProps.getProperty('appconf.logsVerbose')
    appconfScriptsTimeout = buildProps.getProperty('appconf.scriptsTimeout')
    appconfDownloadId = buildProps.getProperty('appconf.downloadId')
    appconfIncludePR = buildProps.getProperty('appconf.IncludePR')

    // Release configuration
    releaseName = 'Bearsampp'
    releaseFullVersion = buildProps.getProperty('release.default.version')
    releaseFormat = buildProps.getProperty('release.format')
    releaseReleaseType = buildProps.getProperty('release.release.type')

    // Development and build directories
    devDir = buildProps.getProperty('dev.dir')
    buildDirName = buildProps.getProperty('build.dir')
    devPath = file("${projectDir}/${devDir}")
    
    // Use build.dir from properties - can be absolute or relative path
    def buildDirPath = buildDirName.startsWith('/') || buildDirName.contains(':') ? 
        buildDirName : "${projectDir}/${buildDirName}"
    buildOutputPath = file(buildDirPath)
    buildReleasePath = file("${buildOutputPath}/release")
    buildTmpPath = file("${buildOutputPath}/tmp")
    releaseTmpPath = file("${buildTmpPath}/release")
    releaseBasePath = file("${releaseTmpPath}/base")
    buildLaunchPath = file("${buildOutputPath}/launch")

    // Binaries versions
    binApacheVersion = buildProps.getProperty('bin.apache.version')
    binMailpitVersion = buildProps.getProperty('bin.mailpit.version')
    binMariaVersion = buildProps.getProperty('bin.mariadb.version')
    binMemcachedVersion = buildProps.getProperty('bin.memcached.version')
    binMysqlVersion = buildProps.getProperty('bin.mysql.version')
    binNodejsVersion = buildProps.getProperty('bin.nodejs.version')
    binPhpVersion = buildProps.getProperty('bin.php.version')
    binPostgresqlVersion = buildProps.getProperty('bin.postgresql.version')
    binXlightVersion = buildProps.getProperty('bin.xlight.version')

    // Applications versions
    appPhpmyadminVersion = buildProps.getProperty('app.phpmyadmin.version')
    appPhppgadminVersion = buildProps.getProperty('app.phppgadmin.version')

    // Tools versions
    toolBrunoVersion = buildProps.getProperty('tool.bruno.version')
    toolComposerVersion = buildProps.getProperty('tool.composer.version')
    toolGhostscriptVersion = buildProps.getProperty('tool.ghostscript.version')
    toolGitVersion = buildProps.getProperty('tool.git.version')
    toolNgrokVersion = buildProps.getProperty('tool.ngrok.version')
    toolPerlVersion = buildProps.getProperty('tool.perl.version')
    toolPowershellVersion = buildProps.getProperty('tool.powershell.version')
    toolPythonVersion = buildProps.getProperty('tool.python.version')
    toolRubyVersion = buildProps.getProperty('tool.ruby.version')

    // BEARSAMPP_PATH property
    bearsamppPath = file("${projectDir}/bearsampp-destination")

    // URLs
    binApacheUrl = 'https://github.com/Bearsampp/module-apache/releases'
    binXlightUrl = 'https://github.com/Bearsampp/module-xlight/releases'
    binMailpitUrl = 'https://github.com/Bearsampp/module-mailpit/releases'
    binMariaUrl = 'https://github.com/Bearsampp/module-mariadb/releases'
    binPostgresqlUrl = 'https://github.com/Bearsampp/module-postgresql/releases'
    binMemcachedUrl = 'https://github.com/Bearsampp/module-memcached/releases'
    binMysqlUrl = 'https://github.com/Bearsampp/module-mysql/releases'
    binNodejsUrl = 'https://github.com/Bearsampp/module-nodejs/releases'
    binPhpUrl = 'https://github.com/Bearsampp/module-php/releases'

    appPhpmyadminUrl = 'https://github.com/Bearsampp/module-phpmyadmin/releases'
    appPhppgadminUrl = 'https://github.com/Bearsampp/module-phppgadmin/releases'

    toolBrunoUrl = 'https://github.com/Bearsampp/module-bruno/releases'
    toolComposerUrl = 'https://github.com/Bearsampp/module-composer/releases'
    toolGhostscriptUrl = 'https://github.com/Bearsampp/module-ghostscript/releases'
    toolGitUrl = 'https://github.com/Bearsampp/module-git/releases'
    toolNgrokUrl = 'https://github.com/Bearsampp/module-ngrok/releases'
    toolPerlUrl = 'https://github.com/Bearsampp/module-perl/releases'
    toolPowershellUrl = 'https://github.com/Bearsampp/module-powershell/releases'
    toolPythonUrl = 'https://github.com/Bearsampp/module-python/releases'
    toolRubyUrl = 'https://github.com/Bearsampp/module-ruby/releases'
}

// Helper function to download and extract modules
def downloadModule(String releasesUrl, String version, File destDir) {
    println "** Get Module"
    println "* Releases url : ${releasesUrl}"
    println "* Version      : ${version}"
    println "* Destination  : ${destDir}"

    def getmTmpPath = file("${buildTmpPath}/getmodule")
    getmTmpPath.mkdirs()

    try {
        def repoUrl = releasesUrl.replace('/releases', '').replace('github.com', 'raw.githubusercontent.com')
        def releasesPropsUrl = "${repoUrl}/main/releases.properties"
        def propsFile = file("${getmTmpPath}/releases-${version}.properties")

        println "* Fetching release properties from: ${releasesPropsUrl}"

        ant.get(src: releasesPropsUrl, dest: propsFile, verbose: true, ignoreerrors: false)

        def releaseProps = new Properties()
        propsFile.withInputStream { releaseProps.load(it) }

        def downloadUrl = releaseProps.getProperty(version)
        if (!downloadUrl) {
            throw new GradleException("Version ${version} not found in releases.properties")
        }

        println "* Download URL : ${downloadUrl}"

        def filename = downloadUrl.substring(downloadUrl.lastIndexOf('/') + 1)
        def downloadFile = file("${getmTmpPath}/${filename}")

        if (!downloadFile.exists()) {
            println "* Downloading ${filename}..."
            ant.get(src: downloadUrl, dest: downloadFile, verbose: true)
        } else {
            println "* Using cached ${filename}"
        }

        println "* Extracting ${filename} to ${destDir}..."
        destDir.mkdirs()

        if (filename.endsWith('.7z')) {
            def sevenZipExe = file("${devPath}/tools/7zip/7za.exe")
            if (!sevenZipExe.exists()) {
                throw new GradleException("7-Zip not found at ${sevenZipExe}")
            }
            def extractProcess = new ProcessBuilder(sevenZipExe.absolutePath, 'x', downloadFile.absolutePath, "-o${destDir.absolutePath}", '-y')
                .directory(destDir)
                .redirectErrorStream(true)
                .start()
            extractProcess.waitFor()
        } else if (filename.endsWith('.zip')) {
            ant.unzip(src: downloadFile, dest: destDir)
        } else {
            throw new GradleException("Unknown archive format: ${filename}")
        }

        println "* Module extracted successfully"

    } catch (Exception e) {
        println "ERROR: Failed to download module: ${e.message}"
        destDir.mkdirs()
        println "WARNING: Created empty directory as fallback"
    }
}

// Helper function to compress using 7-Zip
def compressArchive(File sourceDir, File destFile, String format = '7z') {
    println "** Compressing Archive"
    println "* Source      : ${sourceDir}"
    println "* Destination : ${destFile}"
    println "* Format      : ${format}"

    def sevenZipExe = file("${devPath}/tools/7zip/7za.exe")
    if (!sevenZipExe.exists()) {
        throw new GradleException("7-Zip not found at ${sevenZipExe}")
    }

    destFile.parentFile.mkdirs()

    if (destFile.exists()) {
        destFile.delete()
    }

    if (format == '7z') {
        def compressProcess = new ProcessBuilder(sevenZipExe.absolutePath, 'a', '-t7z', destFile.absolutePath,
                    "${sourceDir.absolutePath}${File.separator}*",
                    '-m0=LZMA2', '-mx9', '-mmt6')
            .directory(sourceDir.parentFile)
            .redirectErrorStream(true)
            .start()
        compressProcess.waitFor()
    } else if (format == 'zip') {
        def compressProcess = new ProcessBuilder(sevenZipExe.absolutePath, 'a', destFile.absolutePath,
                    "${sourceDir.absolutePath}${File.separator}*",
                    '-mm=Deflate', '-mfb=258', '-mpass=15', '-r')
            .directory(sourceDir.parentFile)
            .redirectErrorStream(true)
            .start()
        compressProcess.waitFor()
    } else {
        throw new GradleException("Unknown compression format: ${format}")
    }

    println "* Archive created successfully: ${destFile.name}"
}

// Helper function to generate checksums
def generateChecksums(File file) {
    println "** Generating Checksums"
    println "* File: ${file.name}"

    def algorithms = ['MD5', 'SHA-1', 'SHA-256', 'SHA-512']
    def checksums = [:]

    algorithms.each { algorithm ->
        def checksumFile = new File("${file.absolutePath}.${algorithm.toLowerCase().replace('-', '')}")

        ant.checksum(file: file, algorithm: algorithm, fileext: ".${algorithm.toLowerCase().replace('-', '')}")

        if (checksumFile.exists()) {
            def checksumContent = checksumFile.text.trim()
            def hash = checksumContent.split(/\s+/)[0]
            checksums[algorithm] = hash
            println "* ${algorithm.padRight(10)}: ${hash}"
        }
    }

    return checksums
}

// Helper function to apply token filters to a file
def applyTokenFilters(File sourceFile, File destFile, Map<String, String> tokens) {
    def content = sourceFile.text
    tokens.each { token, value ->
        if (value != null) {
            content = content.replaceAll("@${token}@", value)
        }
    }
    destFile.text = content
}

// Helper function to safely delete a directory with retry logic
def safeDelete(File dir) {
    if (!dir.exists()) {
        return true
    }
    
    def maxRetries = 5
    def retryCount = 0
    def deleted = false
    
    while (retryCount < maxRetries && !deleted) {
        try {
            delete dir
            deleted = true
        } catch (Exception e) {
            retryCount++
            if (retryCount < maxRetries) {
                println "* Retry ${retryCount}/${maxRetries}: Waiting for file locks to release..."
                Thread.sleep(2000)
            } else {
                println "* WARNING: Could not delete directory after ${maxRetries} attempts: ${dir}"
                println "* Error: ${e.message}"
                println "* Please close any applications that may have files open in this directory."
                return false
            }
        }
    }
    
    return deleted
}

// Helper function to comment out specific config lines
def commentOutConfigLines(File confFile, List<String> linePrefixes) {
    def lines = confFile.readLines()
    def newLines = []
    
    lines.each { line ->
        def shouldComment = false
        linePrefixes.each { prefix ->
            if (line.trim().startsWith(prefix) && !line.trim().startsWith(';')) {
                shouldComment = true
            }
        }
        if (shouldComment) {
            newLines << ";${line}"
        } else {
            newLines << line
        }
    }
    
    confFile.text = newLines.join('\n')
}

// Helper function to load build configuration from INI file
def loadBuildConfig(String configFile) {
    def config = [bins: [:], apps: [:], tools: [:]]
    def currentSection = null
    
    file(configFile).eachLine { line ->
        line = line.trim()
        
        // Skip comments and empty lines
        if (line.startsWith('#') || line.startsWith(';') || line.isEmpty()) {
            return
        }
        
        // Check for section headers
        if (line.startsWith('[') && line.endsWith(']')) {
            currentSection = line[1..-2]
            return
        }
        
        // Parse key=value pairs
        if (currentSection && line.contains('=')) {
            def parts = line.split('=', 2)
            def key = parts[0].trim()
            def value = parts[1].trim()
            config[currentSection][key] = value
        }
    }
    
    return config
}

// Helper function to get modules to download based on config
def getModulesToDownload(Map config, String type) {
    def modules = []
    config[type].each { module, enabled ->
        if (enabled == '1') {
            modules << module
        }
    }
    return modules
}

// Helper function to get modules to comment out based on config
def getModulesToComment(Map config) {
    def toComment = []
    
    // For bins, DON'T comment out - they are handled dynamically by the enable=0/1 flag
    // The application checks the enable flag to determine if a bin should be used
    
    // For apps and tools, comment out version lines when disabled (they don't have enable flags)
    config.apps.each { module, enabled ->
        if (enabled == '0') {
            toComment << "${module}Version"
        }
    }
    
    config.tools.each { module, enabled ->
        if (enabled == '0') {
            toComment << "${module}Version"
        }
    }
    
    return toComment
}

// Helper function to get enable tokens based on config
def getEnableTokens(Map config) {
    def tokens = [:]
    
    config.bins.each { module, enabled ->
        def tokenName = "BIN_${module.toUpperCase()}_ENABLE"
        tokens[tokenName] = enabled
    }
    
    return tokens
}

// Task: updateVersions
task updateVersions {
    group = 'build setup'
    description = 'Update module versions from GitHub releases.properties files'

    doLast {
        println "*** Updating module versions from GitHub"
        
        def buildPropsFile = file('build.properties')
        def confFile = file("${projectDir}/base/bearsampp.conf")
        def tmpDir = file("${buildTmpPath}/version-check")
        tmpDir.mkdirs()
        
        // Discover modules from bearsampp.conf
        def confLines = confFile.readLines()
        def modulesMap = [:]
        def confSection = null
        
        confLines.each { line ->
            if (line.contains('; ---- BINS ----')) confSection = 'bin'
            else if (line.contains('; ---- TOOLS ----')) confSection = 'tool'
            else if (line.contains('; ---- APPS ----')) confSection = 'app'
            
            if (confSection && line.contains('Version = "@') && !line.startsWith(';')) {
                def parts = line.split('=')
                if (parts.size() >= 2) {
                    def varName = parts[0].trim()
                    def moduleName = varName.replaceAll('Version$', '')
                    def propName = "${confSection}.${moduleName}.version"
                    modulesMap[propName] = "module-${moduleName}"
                }
            }
        }
        
        println "* Discovered ${modulesMap.size()} modules"
        
        // Read current build.properties
        def propsLines = buildPropsFile.readLines()
        def newLines = []
        def propsSection = null
        def addedProps = [] as Set
        
        for (int i = 0; i < propsLines.size(); i++) {
            def line = propsLines[i]
            newLines << line
            
            // Track sections
            if (line.startsWith('# Binaries versions')) propsSection = 'bin'
            else if (line.startsWith('# Applications versions')) propsSection = 'app'
            else if (line.startsWith('# Tools versions')) propsSection = 'tool'
            
            // Check if we should insert missing entries after this line
            if (propsSection && line.startsWith("${propsSection}.") && line.contains('=')) {
                def currentProp = line.split('=')[0].trim()
                
                // Find missing props that should go after current line
                modulesMap.each { propName, repoName ->
                    if (propName.startsWith("${propsSection}.") && !addedProps.contains(propName)) {
                        def propExists = propsLines.any { it.startsWith("${propName} ") || it.startsWith("${propName}=") }
                        
                        if (!propExists && propName > currentProp) {
                            // Check next line
                            def hasNext = i + 1 < propsLines.size()
                            def nextLine = hasNext ? propsLines[i + 1] : ''
                            def nextProp = nextLine.startsWith("${propsSection}.") ? nextLine.split('=')[0].trim() : null
                            
                            if (!nextProp || propName < nextProp) {
                                newLines << "${propName} = 0.0.0"
                                addedProps << propName
                                println "  [ADD] ${propName}"
                            }
                        }
                    }
                }
            }
        }
        
        buildPropsFile.text = newLines.join('\n')
        
        // Now update versions from GitHub
        propsLines = buildPropsFile.readLines()
        def updatedLines = []
        
        propsLines.each { line ->
            def updated = line
            
            modulesMap.each { propName, repoName ->
                if (line.startsWith("${propName} ") || line.startsWith("${propName}=")) {
                    try {
                        def url = "https://raw.githubusercontent.com/Bearsampp/${repoName}/main/releases.properties"
                        def propsFile = file("${tmpDir}/${repoName}.properties")
                        
                        println "* Fetching ${propName}"
                        ant.get(src: url, dest: propsFile, verbose: false, ignoreerrors: false)
                        
                        def releaseProps = new Properties()
                        propsFile.withInputStream { releaseProps.load(it) }
                        
                        def versions = releaseProps.stringPropertyNames().toList()
                        if (!versions.isEmpty()) {
                            // Filter out date-like versions and versions with year suffixes
                            def validVersions = versions.findAll { version ->
                                def parts = version.split('[.-]')
                                
                                // Check if first part looks like a year (exclude date-like versions)
                                if (parts.length > 0 && parts[0].isInteger()) {
                                    def firstPart = parts[0].toInteger()
                                    // Exclude versions that start with a year (> 2100 or look like dates)
                                    if (firstPart >= 2000) {
                                        return false
                                    }
                                }
                                
                                // Check if any part after the first 3 looks like a year (e.g., 3.4.7-2025)
                                if (parts.length > 3) {
                                    for (int i = 3; i < parts.length; i++) {
                                        if (parts[i].isInteger()) {
                                            def part = parts[i].toInteger()
                                            // Exclude if this part looks like a year (2000-2100)
                                            if (part >= 2000 && part <= 2100) {
                                                return false
                                            }
                                        }
                                    }
                                }
                                
                                return true
                            }
                            
                            if (!validVersions.isEmpty()) {
                                def latest = validVersions.sort { a, b ->
                                    def aParts = a.split('[.-]')
                                    def bParts = b.split('[.-]')
                                    for (int j = 0; j < Math.max(aParts.length, bParts.length); j++) {
                                        def aVal = j < aParts.length ? (aParts[j].isInteger() ? aParts[j].toInteger() : 0) : 0
                                        def bVal = j < bParts.length ? (bParts[j].isInteger() ? bParts[j].toInteger() : 0) : 0
                                        if (aVal != bVal) return bVal - aVal
                                    }
                                    return 0
                                }[0]
                                
                                updated = "${propName} = ${latest}"
                                println "  [OK] Updated to ${latest}"
                            } else {
                                println "  [SKIP] No valid versions found (filtered out date-like versions)"
                            }
                        }
                    } catch (Exception e) {
                        println "  [SKIP] ${e.message}"
                    }
                }
            }
            
            updatedLines << updated
        }
        
        buildPropsFile.text = updatedLines.join('\n')
        println "[DONE] Version update complete"
        delete tmpDir
    }
}

// Override the clean task from base plugin

// Override the clean task from base plugin
clean {
    doFirst {
        println "Cleaning build directory..."
        println "* Build output path: ${buildOutputPath}"
        println "* Absolute path: ${buildOutputPath.absolutePath}"
    }
    doLast {
        if (buildOutputPath.exists()) {
            println "* Deleting build directory: ${buildOutputPath.absolutePath}"
            
            // Use safeDelete helper function with retry logic
            def deleted = safeDelete(buildOutputPath)
            
            if (deleted) {
                println "* Build directory cleaned successfully"
            } else {
                println "* WARNING: Could not fully clean build directory"
                println "* Please close any applications using files in: ${buildOutputPath.absolutePath}"
                println "* Then run 'gradle clean' again"
            }
        } else {
            println "* Build directory does not exist (already clean)"
        }
        
        // Also clean any temporary build artifacts in project directory
        def projectTempDirs = [
            file("${projectDir}/.gradle"),
            file("${projectDir}/build")
        ]
        
        projectTempDirs.each { tempDir ->
            if (tempDir.exists() && tempDir != buildOutputPath) {
                println "* Cleaning project temp directory: ${tempDir.name}"
                try {
                    delete tempDir
                } catch (Exception e) {
                    println "  WARNING: Could not delete ${tempDir.name}: ${e.message}"
                }
            }
        }
    }
}

// Task: initBuild
task initBuild(dependsOn: clean) {
    group = 'build setup'
    description = 'Initialize build environment'

    doLast {
        println "Initializing Bearsampp build environment"
        println "Project base directory: ${projectDir}"
        println "Build directory: ${buildOutputPath}"

        buildOutputPath.mkdirs()
        buildTmpPath.mkdirs()
        releaseTmpPath.mkdirs()
        buildReleasePath.mkdirs()

        println "Dev path: ${devPath}"
        if (!devPath.exists()) {
            throw new GradleException("Dev directory '${devPath}' not found")
        }
        println "Bearsampp dev found in ${devPath}"
    }
}

// Task: checkLang
task checkLang(dependsOn: initBuild) {
    group = 'verification'
    description = 'Check language files'

    doLast {
        println "Checking language files..."
        def langsDir = file("${projectDir}/core/langs")
        if (langsDir.exists()) {
            langsDir.listFiles().each { langFile ->
                if (langFile.name.endsWith('.lang')) {
                    println "Found language file: ${langFile.name}"
                }
            }
        }
    }
}

// Task: prepareBase
task prepareBase(dependsOn: [updateVersions, initBuild]) {
    group = 'build'
    description = 'Prepare base environment for Bearsampp'

    doLast {
        println "*** Preparing base"
        println "* Name    : ${releaseName}"
        println "* Version : ${releaseFullVersion}"

        def iconographyUrl = 'https://github.com/Bearsampp/sandbox/releases/download/iconography/Bearsampp-iconography.zip'
        def iconographyZip = file("${projectDir}/Bearsampp-iconography.zip")

        println "Downloading iconography..."
        ant.get(src: iconographyUrl, dest: iconographyZip)
        ant.unzip(src: iconographyZip, dest: projectDir)
        iconographyZip.delete()
        println "Successfully downloaded and extracted Bearsampp iconography."

        def bearsamppExe = file("${projectDir}/base/bearsampp.exe")
        if (bearsamppExe.exists()) {
            def rcEditProcess = new ProcessBuilder('rcedit-x64.exe', bearsamppExe.absolutePath, '--set-file-version', releaseFullVersion)
                .directory(projectDir)
                .redirectErrorStream(true)
                .start()
            rcEditProcess.waitFor()
            println "Successfully set product version to ${releaseFullVersion} using rcedit-x64.exe"
        }

        def fixIconProcess = new ProcessBuilder('cmd', '/c', 'fix-core-icon.bat')
            .directory(projectDir)
            .redirectErrorStream(true)
            .start()
        fixIconProcess.waitFor()
        println "Successfully set icon to bearsampp.ico using ResourceHacker.exe"

        delete releaseBasePath
        releaseBasePath.mkdirs()

        copy {
            from projectDir
            into releaseBasePath
            includeEmptyDirs = true
            exclude { fileTreeElement ->
                def path = fileTreeElement.relativePath.pathString
                def name = fileTreeElement.file.name
                
                // FIRST: NEVER EVER exclude .gitignore files - this takes priority over everything
                if (name == '.gitignore') {
                    return false
                }
                
                // SECOND: NEVER exclude files from these directories - copy everything
                if (path.startsWith('core/tmp/') || path.startsWith('core/logs/') || 
                    path.startsWith('tmp/') || path.startsWith('logs/')) {
                    return false
                }
                
                // Exclude these directories
                if (path.startsWith('.dev/') || path.startsWith('.github/') || 
                    path.startsWith('.idea/') || path.startsWith('.settings/') || 
                    path.startsWith('.gradle/') || path.startsWith('.gradle-docs/') || 
                    path.startsWith('.qodo/')) {
                    return true
                }
                
                // Exclude base and bin directories
                if (path.startsWith('base/') || path.startsWith('bin/')) {
                    return true
                }
                
                // Exclude specific files
                if (path == 'giscus.json' || path == 'core/.editorconfig' || 
                    path == 'build.properties' || path == 'build.xml' || 
                    path == 'build.gradle' || path == 'settings.gradle' ||
                    path == 'ResourceHacker.exe' || path == 'ResourceHacker.ini' ||
                    path == 'fix-core-icon.bat' || path == 'rcedit-x64.exe' ||
                    path == 'Bearsampp-iconography.zip' || path == 'build.xml.reference' ||
                    path == 'buildFull.ini' || path == 'buildBasic.ini' || path == 'buildLite.ini') {
                    return true
                }
                
                // Exclude gradle wrapper files
                if (path.startsWith('gradle/') || path == 'gradlew' || path == 'gradlew.bat') {
                    return true
                }
                
                // Exclude specific file types
                if (name.endsWith('.iml') || name.endsWith('.launch')) {
                    return true
                }
                
                // Exclude git-related files (but NOT .gitignore - already handled above)
                if (path.contains('/.git/') || name == '.gitattributes' || name == '.editorconfig') {
                    return true
                }
                
                return false
            }
        }

        def opensslCfg = file("${projectDir}/core/libs/openssl/openssl.cfg")
        if (!opensslCfg.exists()) {
            opensslCfg.parentFile.mkdirs()
            ant.get(
                src: 'https://github.com/Bearsampp/sandbox/releases/download/2024.8.23/openssl.cfg',
                dest: opensslCfg
            )
            println "openssl.cfg recovered from sandbox"
        } else {
            println "openssl.cfg already exists."
        }

        // Debug: Check what files exist in base/ before copying
        println "Checking base directory contents..."
        def baseDir = file("${projectDir}/base")
        def gitignoreFiles = []
        baseDir.eachFileRecurse { f ->
            if (f.name == '.gitignore') {
                gitignoreFiles << f.absolutePath.replace(baseDir.absolutePath, 'base')
            }
        }
        println "Found ${gitignoreFiles.size()} .gitignore files in base/:"
        gitignoreFiles.each { println "  - ${it}" }
        
        // Copy everything from base/ first
        copy {
            from file("${projectDir}/base")
            into releaseBasePath
            includeEmptyDirs = true
        }
        
        // Manually copy .gitignore files (Gradle excludes them by default)
        println "Manually copying .gitignore files..."
        gitignoreFiles.each { gitignorePath ->
            def sourceFile = file("${projectDir}/${gitignorePath}")
            def destPath = gitignorePath.replace('base\\', '').replace('base/', '')
            def destFile = file("${releaseBasePath}/${destPath}")
            if (sourceFile.exists()) {
                destFile.parentFile.mkdirs()
                destFile.text = sourceFile.text
                println "  [COPY] ${destPath}"
            }
        }
        
        // Now manually delete unwanted files from logs/, ssl/, tmp/, vhosts/ (but keep .gitignore)
        println "Cleaning up temporary directories (keeping .gitignore files)..."
        ['logs', 'ssl', 'tmp', 'vhosts'].each { dirName ->
            def targetDir = file("${releaseBasePath}/${dirName}")
            if (targetDir.exists() && targetDir.isDirectory()) {
                // Recursively process all files in this directory tree
                targetDir.eachFileRecurse { f ->
                    if (f.isFile() && f.name != '.gitignore') {
                        def relativePath = f.absolutePath.replace(releaseBasePath.absolutePath + File.separator, '')
                        println "  [DELETE] ${relativePath}"
                        f.delete()
                    }
                }
            }
        }
        
        // Verify .gitignore files were kept
        println "Verifying .gitignore files in release..."
        def keptGitignores = []
        releaseBasePath.eachFileRecurse { f ->
            if (f.name == '.gitignore') {
                def relativePath = f.absolutePath.replace(releaseBasePath.absolutePath + File.separator, '')
                keptGitignores << relativePath
            }
        }
        println "Found ${keptGitignores.size()} .gitignore files in release:"
        keptGitignores.each { println "  [OK] ${it}" }
        
        // Ensure directories exist (they should already have .gitignore files from copy above)
        file("${releaseBasePath}/logs").mkdirs()
        file("${releaseBasePath}/ssl").mkdirs()
        file("${releaseBasePath}/vhosts").mkdirs()
        
        file("${releaseBasePath}/tmp/cachegrind").mkdirs()
        file("${releaseBasePath}/tmp/npm-cache").mkdirs()
        file("${releaseBasePath}/tmp/openssl").mkdirs()
        file("${releaseBasePath}/tmp/pip").mkdirs()

        def tokens = [
            'APPCONF_LANG': appconfLang,
            'APPCONF_TIMEZONE': appconfTimezone,
            'APPCONF_NOTEPAD': appconfNotepad,
            'APPCONF_MAX_LOGS_ARCHIVES': appconfMaxLogsArchives,
            'APPCONF_LOGS_VERBOSE': appconfLogsVerbose,
            'APPCONF_SCRIPTS_TIMEOUT': appconfScriptsTimeout,
            'APPCONF_DOWNLOAD_ID': appconfDownloadId,
            'APPCONF_INCLUDE_PR': appconfIncludePR,
            'BIN_APACHE_VERSION': binApacheVersion,
            'BIN_PHP_VERSION': binPhpVersion,
            'BIN_MYSQL_VERSION': binMysqlVersion,
            'BIN_MARIADB_VERSION': binMariaVersion,
            'BIN_POSTGRESQL_VERSION': binPostgresqlVersion,
            'BIN_NODEJS_VERSION': binNodejsVersion,
            'BIN_XLIGHT_VERSION': binXlightVersion,
            'BIN_MAILPIT_VERSION': binMailpitVersion,
            'BIN_MEMCACHED_VERSION': binMemcachedVersion,
            'TOOL_BRUNO_VERSION': toolBrunoVersion,
            'TOOL_COMPOSER_VERSION': toolComposerVersion,
            'TOOL_POWERSHELL_VERSION': toolPowershellVersion,
            'TOOL_GHOSTSCRIPT_VERSION': toolGhostscriptVersion,
            'TOOL_GIT_VERSION': toolGitVersion,
            'TOOL_NGROK_VERSION': toolNgrokVersion,
            'TOOL_PERL_VERSION': toolPerlVersion,
            'TOOL_PYTHON_VERSION': toolPythonVersion,
            'TOOL_RUBY_VERSION': toolRubyVersion,
            'APP_PHPMYADMIN_VERSION': appPhpmyadminVersion,
            'APP_PHPPGADMIN_VERSION': appPhppgadminVersion
        ]

        applyTokenFilters(
            file("${projectDir}/base/bearsampp.conf"),
            file("${releaseBasePath}/bearsampp.conf"),
            tokens
        )

        def versionTokens = ['RELEASE_VERSION': releaseFullVersion]
        applyTokenFilters(
            file("${projectDir}/base/bearsampp.ini"),
            file("${releaseBasePath}/bearsampp.ini"),
            versionTokens
        )

        file("${releaseBasePath}/core/resources/version.dat").text = releaseFullVersion
        file("${releaseTmpPath}/version.dat").text = releaseFullVersion
        file("${projectDir}/core/resources/version.dat").text = releaseFullVersion

        // Create lastPath.dat file if it doesn't exist
        def lastPathFile = file("${releaseBasePath}/core/resources/lastPath.dat")
        if (!lastPathFile.exists()) {
            lastPathFile.text = ''
            println "Created lastPath.dat file"
        }
        
        // Clean up any logs that may have been created during build process (but keep .gitignore)
        def logsDir = file("${releaseBasePath}/logs")
        if (logsDir.exists()) {
            logsDir.listFiles().each { logFile ->
                if (logFile.isFile() && logFile.name != '.gitignore') {
                    logFile.delete()
                    println "Removed build-time log: ${logFile.name}"
                }
            }
        }

        println "Base preparation complete"
    }
}

// Task: buildFull
task buildFull(dependsOn: [initBuild, prepareBase]) {
    group = 'build'
    description = 'Build full release package'

    doLast {
        def releaseTarget = file("${releaseTmpPath}/${releaseName}-${releaseFullVersion}")
        def releaseDestFile = "${buildReleasePath}/${releaseName}-${releaseFullVersion}"

        println "*** Release (full)"
        println "* Name    : ${releaseName}"
        println "* Version : ${releaseFullVersion}"
        println "* Format  : ${releaseFormat}"

        safeDelete(releaseTarget)
        releaseTarget.mkdirs()

        copy {
            from releaseBasePath
            into releaseTarget
            includeEmptyDirs = true
        }

        def fullTokens = [
            'BIN_APACHE_ENABLE': '1',
            'BIN_PHP_ENABLE': '1',
            'BIN_MYSQL_ENABLE': '1',
            'BIN_MARIADB_ENABLE': '1',
            'BIN_POSTGRESQL_ENABLE': '1',
            'BIN_NODEJS_ENABLE': '1',
            'BIN_XLIGHT_ENABLE': '1',
            'BIN_MAILPIT_ENABLE': '1',
            'BIN_MEMCACHED_ENABLE': '1'
        ]

        def confContent = file("${releaseBasePath}/bearsampp.conf").text
        fullTokens.each { token, value ->
            confContent = confContent.replaceAll("@${token}@", value)
        }
        file("${releaseTarget}/bearsampp.conf").text = confContent

        println "Downloading binaries..."
        downloadModule(binApacheUrl, binApacheVersion, file("${releaseTarget}/bin/apache"))
        downloadModule(binXlightUrl, binXlightVersion, file("${releaseTarget}/bin/xlight"))
        downloadModule(binMailpitUrl, binMailpitVersion, file("${releaseTarget}/bin/mailpit"))
        downloadModule(binMariaUrl, binMariaVersion, file("${releaseTarget}/bin/mariadb"))
        downloadModule(binPostgresqlUrl, binPostgresqlVersion, file("${releaseTarget}/bin/postgresql"))
        downloadModule(binMemcachedUrl, binMemcachedVersion, file("${releaseTarget}/bin/memcached"))
        downloadModule(binMysqlUrl, binMysqlVersion, file("${releaseTarget}/bin/mysql"))
        downloadModule(binNodejsUrl, binNodejsVersion, file("${releaseTarget}/bin/nodejs"))
        downloadModule(binPhpUrl, binPhpVersion, file("${releaseTarget}/bin/php"))

        println "Downloading applications..."
        downloadModule(appPhpmyadminUrl, appPhpmyadminVersion, file("${releaseTarget}/apps/phpmyadmin"))
        downloadModule(appPhppgadminUrl, appPhppgadminVersion, file("${releaseTarget}/apps/phppgadmin"))

        println "Downloading tools..."
        downloadModule(toolBrunoUrl, toolBrunoVersion, file("${releaseTarget}/tools/bruno"))
        downloadModule(toolComposerUrl, toolComposerVersion, file("${releaseTarget}/tools/composer"))
        downloadModule(toolPowershellUrl, toolPowershellVersion, file("${releaseTarget}/tools/powershell"))
        downloadModule(toolGhostscriptUrl, toolGhostscriptVersion, file("${releaseTarget}/tools/ghostscript"))
        downloadModule(toolGitUrl, toolGitVersion, file("${releaseTarget}/tools/git"))
        downloadModule(toolNgrokUrl, toolNgrokVersion, file("${releaseTarget}/tools/ngrok"))
        downloadModule(toolPerlUrl, toolPerlVersion, file("${releaseTarget}/tools/perl"))
        downloadModule(toolPythonUrl, toolPythonVersion, file("${releaseTarget}/tools/python"))
        downloadModule(toolRubyUrl, toolRubyVersion, file("${releaseTarget}/tools/ruby"))

        println "\n*** Compressing release..."
        def archiveFile = file("${releaseDestFile}.${releaseFormat}")
        compressArchive(releaseTarget, archiveFile, releaseFormat)

        println "\n*** Generating checksums..."
        generateChecksums(archiveFile)

        println "\n*** Build complete!"
        println "* Archive: ${archiveFile.name}"
        println "* Size: ${String.format('%.2f MB', archiveFile.length() / 1024 / 1024)}"
    }
}

// Task: buildBasic
task buildBasic(dependsOn: [initBuild, prepareBase]) {
    group = 'build'
    description = 'Build basic release package'

    doLast {
        def releaseTarget = file("${releaseTmpPath}/${releaseName}-basic-${releaseFullVersion}")
        def releaseDestFile = "${buildReleasePath}/${releaseName}-basic-${releaseFullVersion}"

        println "*** Release (basic)"
        println "* Name    : ${releaseName}"
        println "* Version : ${releaseFullVersion}"
        println "* Format  : ${releaseFormat}"

        safeDelete(releaseTarget)
        releaseTarget.mkdirs()

        copy {
            from releaseBasePath
            into releaseTarget
            includeEmptyDirs = true
        }

        // Load configuration from buildBasic.ini
        def buildConfig = loadBuildConfig("${projectDir}/buildBasic.ini")
        
        // Generate enable tokens from config
        def basicTokens = getEnableTokens(buildConfig)

        def confContent = file("${releaseBasePath}/bearsampp.conf").text
        basicTokens.each { token, value ->
            confContent = confContent.replaceAll("@${token}@", value)
        }
        file("${releaseTarget}/bearsampp.conf").text = confContent
        
        // Comment out unused apps and tools (bins are handled by enable flags)
        def confFile = file("${releaseTarget}/bearsampp.conf")
        def toComment = getModulesToComment(buildConfig)
        if (!toComment.isEmpty()) {
            commentOutConfigLines(confFile, toComment)
        }

        println "Downloading binaries..."
        downloadModule(binApacheUrl, binApacheVersion, file("${releaseTarget}/bin/apache"))
        downloadModule(binXlightUrl, binXlightVersion, file("${releaseTarget}/bin/xlight"))
        downloadModule(binMailpitUrl, binMailpitVersion, file("${releaseTarget}/bin/mailpit"))
        downloadModule(binMariaUrl, binMariaVersion, file("${releaseTarget}/bin/mariadb"))
        downloadModule(binMysqlUrl, binMysqlVersion, file("${releaseTarget}/bin/mysql"))
        downloadModule(binNodejsUrl, binNodejsVersion, file("${releaseTarget}/bin/nodejs"))
        downloadModule(binPhpUrl, binPhpVersion, file("${releaseTarget}/bin/php"))

        println "Downloading applications..."
        downloadModule(appPhpmyadminUrl, appPhpmyadminVersion, file("${releaseTarget}/apps/phpmyadmin"))

        println "Downloading tools..."
        downloadModule(toolBrunoUrl, toolBrunoVersion, file("${releaseTarget}/tools/bruno"))
        downloadModule(toolComposerUrl, toolComposerVersion, file("${releaseTarget}/tools/composer"))
        downloadModule(toolPowershellUrl, toolPowershellVersion, file("${releaseTarget}/tools/powershell"))
        downloadModule(toolGitUrl, toolGitVersion, file("${releaseTarget}/tools/git"))
        downloadModule(toolNgrokUrl, toolNgrokVersion, file("${releaseTarget}/tools/ngrok"))
        downloadModule(toolPerlUrl, toolPerlVersion, file("${releaseTarget}/tools/perl"))

        println "\n*** Compressing release..."
        def archiveFile = file("${releaseDestFile}.${releaseFormat}")
        compressArchive(releaseTarget, archiveFile, releaseFormat)

        println "\n*** Generating checksums..."
        generateChecksums(archiveFile)

        println "\n*** Build complete!"
        println "* Archive: ${archiveFile.name}"
        println "* Size: ${String.format('%.2f MB', archiveFile.length() / 1024 / 1024)}"
    }
}

// Task: buildLite
task buildLite(dependsOn: [initBuild, prepareBase]) {
    group = 'build'
    description = 'Build lite release package'

    doLast {
        def releaseTarget = file("${releaseTmpPath}/${releaseName}-lite-${releaseFullVersion}")
        def releaseDestFile = "${buildReleasePath}/${releaseName}-lite-${releaseFullVersion}"

        println "*** Release (lite)"
        println "* Name    : ${releaseName}"
        println "* Version : ${releaseFullVersion}"
        println "* Format  : ${releaseFormat}"

        safeDelete(releaseTarget)
        releaseTarget.mkdirs()

        copy {
            from releaseBasePath
            into releaseTarget
            includeEmptyDirs = true
        }

        // Load configuration from buildLite.ini
        def buildConfig = loadBuildConfig("${projectDir}/buildLite.ini")
        
        // Generate enable tokens from config
        def liteTokens = getEnableTokens(buildConfig)

        def confContent = file("${releaseBasePath}/bearsampp.conf").text
        liteTokens.each { token, value ->
            confContent = confContent.replaceAll("@${token}@", value)
        }
        file("${releaseTarget}/bearsampp.conf").text = confContent
        
        // Comment out unused apps and tools (bins are handled by enable flags)
        def confFile = file("${releaseTarget}/bearsampp.conf")
        def toComment = getModulesToComment(buildConfig)
        if (!toComment.isEmpty()) {
            commentOutConfigLines(confFile, toComment)
        }

        // Download ALL bins (even disabled ones) because the app needs their config files
        // Only download enabled apps and tools
        def appsToDownload = getModulesToDownload(buildConfig, 'apps')
        def toolsToDownload = getModulesToDownload(buildConfig, 'tools')

        println "Downloading binaries (all bins needed for config files)..."
        downloadModule(binApacheUrl, binApacheVersion, file("${releaseTarget}/bin/apache"))
        downloadModule(binPhpUrl, binPhpVersion, file("${releaseTarget}/bin/php"))
        downloadModule(binMysqlUrl, binMysqlVersion, file("${releaseTarget}/bin/mysql"))
        downloadModule(binMariaUrl, binMariaVersion, file("${releaseTarget}/bin/mariadb"))
        downloadModule(binPostgresqlUrl, binPostgresqlVersion, file("${releaseTarget}/bin/postgresql"))
        downloadModule(binNodejsUrl, binNodejsVersion, file("${releaseTarget}/bin/nodejs"))
        downloadModule(binXlightUrl, binXlightVersion, file("${releaseTarget}/bin/xlight"))
        downloadModule(binMailpitUrl, binMailpitVersion, file("${releaseTarget}/bin/mailpit"))
        downloadModule(binMemcachedUrl, binMemcachedVersion, file("${releaseTarget}/bin/memcached"))

        println "Downloading applications (only enabled)..."
        def appUrls = [
            phpmyadmin: [url: appPhpmyadminUrl, version: appPhpmyadminVersion],
            phppgadmin: [url: appPhppgadminUrl, version: appPhppgadminVersion]
        ]
        appsToDownload.each { moduleName ->
            def moduleInfo = appUrls[moduleName]
            if (moduleInfo) {
                downloadModule(moduleInfo.url, moduleInfo.version, file("${releaseTarget}/apps/${moduleName}"))
            }
        }

        println "Downloading tools (only enabled)..."
        def toolUrls = [
            bruno: [url: toolBrunoUrl, version: toolBrunoVersion],
            composer: [url: toolComposerUrl, version: toolComposerVersion],
            powershell: [url: toolPowershellUrl, version: toolPowershellVersion],
            ghostscript: [url: toolGhostscriptUrl, version: toolGhostscriptVersion],
            git: [url: toolGitUrl, version: toolGitVersion],
            ngrok: [url: toolNgrokUrl, version: toolNgrokVersion],
            perl: [url: toolPerlUrl, version: toolPerlVersion],
            python: [url: toolPythonUrl, version: toolPythonVersion],
            ruby: [url: toolRubyUrl, version: toolRubyVersion]
        ]
        toolsToDownload.each { moduleName ->
            def moduleInfo = toolUrls[moduleName]
            if (moduleInfo) {
                downloadModule(moduleInfo.url, moduleInfo.version, file("${releaseTarget}/tools/${moduleName}"))
            }
        }

        println "\n*** Compressing release..."
        def archiveFile = file("${releaseDestFile}.${releaseFormat}")
        compressArchive(releaseTarget, archiveFile, releaseFormat)

        println "\n*** Generating checksums..."
        generateChecksums(archiveFile)

        println "\n*** Build complete!"
        println "* Archive: ${archiveFile.name}"
        println "* Size: ${String.format('%.2f MB', archiveFile.length() / 1024 / 1024)}"
    }
}

// Task: sync
task sync(dependsOn: buildFull) {
    group = 'build'
    description = 'Sync build to sandbox'

    doLast {
        println "\n*** Sync to Sandbox ***"

        def console = System.console()
        def syncConfirm
        if (console) {
            syncConfirm = console.readLine('Would you like to sync to sandbox? (y/yes or n/no): ')
        } else {
            println "Running in non-interactive mode. Skipping sync."
            return
        }

        if (!(syncConfirm ==~ /(?i)^(yes|y)$/)) {
            println "Sync aborted by user."
            return
        }

        println "\nCurrent sync path is: ${bearsamppPath}"
        def pathConfirm = console.readLine('Is this the path you want to sync to? (y/yes or n/no): ')

        def syncFinalPath = bearsamppPath
        if (!(pathConfirm ==~ /(?i)^(yes|y)$/)) {
            def customPath = console.readLine('Please enter the new path to sync to: ')
            if (customPath && customPath.trim()) {
                syncFinalPath = file(customPath.trim())
            }
        }

        println "\n*** Sync step: using path = ${syncFinalPath}"

        def iconographyUrl = 'https://github.com/Bearsampp/sandbox/releases/download/iconography/Sandbox-iconography.zip'
        def iconographyTempDir = file("${buildTmpPath}/bearsampp-iconography-temp")
        def iconographyZip = file("${iconographyTempDir}/Sandbox-iconography.zip")

        println "* Downloading Sandbox iconography..."
        iconographyTempDir.mkdirs()
        ant.get(src: iconographyUrl, dest: iconographyZip)
        ant.unzip(src: iconographyZip, dest: iconographyTempDir)
        iconographyZip.delete()
        println "* Successfully downloaded and extracted Sandbox iconography"

        println "* Copying base core files..."
        copy {
            from file("${releaseTmpPath}/base/core")
            into file("${iconographyTempDir}/core")
            overwrite true
        }

        println "* Preparing executable..."
        copy {
            from file("${projectDir}/base/bearsampp.exe")
            into iconographyTempDir
            overwrite true
        }

        copy {
            from file("${projectDir}/rcedit-x64.exe")
            into iconographyTempDir
            overwrite true
        }

        def resourceHackerSource = file("${syncFinalPath}/ResourceHacker.exe")
        if (resourceHackerSource.exists()) {
            copy {
                from resourceHackerSource
                into iconographyTempDir
                overwrite true
            }
        } else {
            println "WARNING: ResourceHacker.exe not found at ${resourceHackerSource}"
        }

        println "* Updating executable version to ${releaseFullVersion}..."
        def rcEditExe = file("${iconographyTempDir}/rcedit-x64.exe")
        def tempBearsamppExe = file("${iconographyTempDir}/bearsampp.exe")

        def rcEditProcess = new ProcessBuilder(rcEditExe.absolutePath, tempBearsamppExe.absolutePath,
                    '--set-file-version', releaseFullVersion)
            .directory(iconographyTempDir)
            .redirectErrorStream(true)
            .start()
        rcEditProcess.waitFor()
        println "* Successfully set product version to ${releaseFullVersion}"

        println "* Copying icons to sync path..."
        def iconsSource = file("${iconographyTempDir}/core/resources/homepage/img/icons")
        def iconsDest = file("${syncFinalPath}/core/resources/homepage/img/icons")

        if (iconsSource.exists()) {
            copy {
                from iconsSource
                into iconsDest
                overwrite true
            }
        }

        println "* Updating executable icon..."
        def resourceHackerExe = file("${iconographyTempDir}/ResourceHacker.exe")
        def iconPath = file("${syncFinalPath}/core/resources/homepage/img/icons/bearsampp.ico")

        if (resourceHackerExe.exists() && iconPath.exists()) {
            def resourceHackerProcess = new ProcessBuilder(resourceHackerExe.absolutePath,
                        '-open', tempBearsamppExe.absolutePath,
                        '-save', tempBearsamppExe.absolutePath,
                        '-action', 'modify',
                        '-res', "${iconPath.absolutePath},",
                        '-mask', 'ICONGROUP,MAINICON,')
                .directory(iconographyTempDir)
                .redirectErrorStream(true)
                .start()
            resourceHackerProcess.waitFor()
            println "* Successfully updated executable icon"
        } else {
            println "WARNING: Could not update icon - ResourceHacker or icon file not found"
        }

        def finalBearsamppExe = file("${syncFinalPath}/bearsampp.exe")
        if (finalBearsamppExe.exists()) {
            finalBearsamppExe.delete()
        }

        println "* Copying updated executable to sync path..."
        copy {
            from tempBearsamppExe
            into syncFinalPath
            overwrite true
        }

        println "\n*** Sync complete!"
        println "* Synced to: ${syncFinalPath}"
        println "* Executable updated with version ${releaseFullVersion}"
    }
}

// Task: release
task release(dependsOn: [initBuild, prepareBase, buildFull, buildBasic, buildLite, sync]) {
    group = 'build'
    description = 'Release Bearsampp (all variants) - includes clean'

    doLast {
        println "Release complete!"
        println "All build variants have been created."
    }
}

// Task: launch
task launch(dependsOn: buildFull) {
    group = 'application'
    description = 'Launch Bearsampp'

    doLast {
        def releaseTarget = file("${releaseTmpPath}/${releaseName}-${releaseFullVersion}")

        if (!releaseTarget.exists()) {
            throw new GradleException("Release target directory not found: ${releaseTarget}")
        }

        delete buildLaunchPath
        buildLaunchPath.mkdirs()

        copy {
            from releaseTarget
            into buildLaunchPath
        }

        println "Executing Bearsampp. Please wait..."
        def bearsamppExe = file("${buildLaunchPath}/bearsampp.exe")
        if (bearsamppExe.exists()) {
            def launchProcess = new ProcessBuilder(bearsamppExe.absolutePath)
                .directory(buildLaunchPath)
                .start()
        }
        println "If the application needs to restart, you can execute Bearsampp.exe in: ${buildLaunchPath}"
    }
}

// Disable the built-in wrapper task since Gradle is locally installed
tasks.named('wrapper') {
    doFirst {
        throw new GradleException("The wrapper task is disabled. Gradle is installed locally on this system.")
    }
}

// Default task
defaultTasks 'release'
